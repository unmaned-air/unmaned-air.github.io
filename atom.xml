<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://unmaned-air.github.io</id>
    <title>Gridea</title>
    <updated>2022-05-27T15:58:45.846Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://unmaned-air.github.io"/>
    <link rel="self" href="https://unmaned-air.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://unmaned-air.github.io/images/avatar.png</logo>
    <icon>https://unmaned-air.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[期末前夕的C++]]></title>
        <id>https://unmaned-air.github.io/post/qi-mo-qian-xi-de-c/</id>
        <link href="https://unmaned-air.github.io/post/qi-mo-qian-xi-de-c/">
        </link>
        <updated>2022-05-27T03:17:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>以下是我在复习的过程中发现的华点</p>
</blockquote>
<h3 id="一些容易被搞到的知识点">一些容易被搞到的知识点</h3>
<ul>
<li>编写C++程序一般需要经过的几个步骤依次是：<em>编辑、编译、连接、运行</em></li>
<li><a href="https://unmaned-air.github.io/post/fu-zhi-jian-rong-xing-gui-ze/">赋值兼容性规则</a>是指派生类对象可以当作基类对象使用，只要存在继承关系，所以单继承或多继承都适用。</li>
<li></li>
</ul>
<h3 id="空指针和野指针">空指针和野指针</h3>
<p><strong>空指针：</strong> 指针变量指向内存中编号为0的空间，可以初始化指针变量（<em>因为野指针野一点</em>），但空指针指向的内存是不可以访问的。<br>
<strong>野指针：</strong> 指针变量指向非法的空间（<em>比如指向地址编号为某某的空间，比如指针指向数组溢出的位置</em>）</p>
<h3 id="const修饰指针">const修饰指针</h3>
<ul>
<li>常量的指针（<em>const int</em>  *p）<br>
指针指向可以修改，但指针指向的值不可修改<br>
<em>理解为const int 后面带了个  * 指针</em></li>
<li>指针的常量（<em>int * const</em>）<br>
指针指向不可修改，指针指向的值可以修改<br>
<em>理解为 * 后面带着const ，const关键字修饰的是指针变量</em></li>
<li>同时修饰<br>
指针指向与指针指向的值都不可以修改。</li>
</ul>
<pre><code class="language-C++">int main() {

	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &amp;a; 
	p1 = &amp;b; //正确
	//*p1 = 100;  报错
	

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &amp;a;
	//p2 = &amp;b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &amp;a;
	//p3 = &amp;b; //错误
	//*p3 = 100; //错误

	system(&quot;pause&quot;);

	return 0;
}
</code></pre>
<h3 id="内存分区模型">内存分区模型</h3>
<ol>
<li>代码区：就是代码所占的内存；</li>
<li>全局区：存放全局变量和静态变量；</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值、局部变量等；</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。（<em>new</em>）</li>
</ol>
<blockquote>
<p>不同区域存放的数据赋予不同的生命周期，给我们更大的灵活编程</p>
</blockquote>
<h3 id="new操作符">new操作符</h3>
<p>C++中利用new操作符在堆区开辟内存，在程序的最后要记得 <em>delete</em> 数据。<br>
利用new创建的数据，会返回该数据对应类型的指针。<br>
需要注意的是开辟数组的时候的操作是层层覆盖的。</p>
<ul>
<li>示例1</li>
</ul>
<pre><code class="language-C++">int* func()
{
	int* a = new int(10);
	return a;
}
int main() {
	int *p = func();
	cout &lt;&lt; *p &lt;&lt; endl;
	//利用delete释放堆区数据
	delete p;
	//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问
	return 0;
}
</code></pre>
<ul>
<li>示例2</li>
</ul>
<pre><code class="language-C++">//堆区开辟数组
int main() {
	int* arr = new int[10];
	for (int i = 0; i &lt; 10; i++)
	{
		arr[i] = i + 100;
	}
	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;
	return 0;
}
</code></pre>
<ul>
<li>示例3</li>
</ul>
<pre><code class="language-C++">//动态内存分配
//new开辟二维数组空间
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

void chan(int **a)
{
	int b[3][3];
	for (int i = 0; i &lt; 3; ++i)
		for (int j = 0; j &lt; 3; ++j)
			b[i][j] = a[j][i];
	for (int i = 0; i &lt; 3; ++i)
		for (int j = 0; j &lt; 3; ++j)
			a[i][j] = b[i][j];
}

int main()
{
	int **a;
	a = new int*[3];
	for (int i = 0; i &lt; 3; ++i)
		a[i] = new int[3];
	int k = 0;

	for (int i = 0; i &lt; 3; ++i)
		for (int j = 0; j &lt; 3; ++j)
			a[i][j] = k++;

	chan(a);
	for (int i = 0; i &lt; 3; ++i)
	{
		for (int j = 0; j &lt; 3; ++j)
			cout &lt;&lt; a[i][j] &lt;&lt; ' ';
		cout &lt;&lt; endl;
	}
	for (int i = 0; i &lt; 3; ++i)
		delete[] a[i];
	delete[] a;
	return 0;
}
</code></pre>
<h3 id="引用">引用</h3>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>引用必须初始化。</li>
</ul>
<blockquote>
<p>引用变量是一个别名，也就是说它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
</blockquote>
<ul>
<li>引用在初始化之后不可以改变。</li>
</ul>
<h5 id="引用和指针的不同之处">引用和指针的不同之处</h5>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化一个对象，就不能被指向到另一个对象。指针可以再任何时候指向到另一个对象。但是指针可以在 <strong>任何时间</strong> 指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化</li>
</ul>
<h5 id="把引用作为参数值与返回值">把引用作为参数值与返回值</h5>
<pre><code>C中有利用&amp;达到传入数字进行swap操作，C++中同样有类似操作
</code></pre>
<pre><code class="language-C">#include&lt;stdio.h&gt;
void swap(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}
int main()
{
	int a = 10;
	int b = 20;
	swap(&amp;a, &amp;b);
	printf(&quot;%d,%d&quot;, a, b);
	return 0;
}
</code></pre>
<ul>
<li>C++中把引用作为参数</li>
</ul>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
void swap(int&amp; x, int&amp; y);
int main ()
{
   int a = 100;
   int b = 200;
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
   swap(a, b);//最突出的一点是a,b不带任何符号，但却能进行换位
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
}
void swap(int&amp; x, int&amp; y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于kali虚拟机的网络渗透技术(二)scapy DHCP基础]]></title>
        <id>https://unmaned-air.github.io/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-ji-zhu-yi-scapy-dhcp-ji-chu/</id>
        <link href="https://unmaned-air.github.io/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-ji-zhu-yi-scapy-dhcp-ji-chu/">
        </link>
        <updated>2022-04-26T02:19:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="dhcp协议概要">DHCP协议概要</h3>
<blockquote>
<p>动态主机配置协议（<em>Dynamic Host Comfiguration Protocol</em>），工作在应用层，是一个局域网的协议，主要用来给内部网络自动分配IP地址。<br>
DHCP服务器保管着IP地址，分配方式是按照硬件地址（MAC）分配IP地址。</p>
</blockquote>
<h3 id="dhcp的工作原理与流程">DHCP的工作原理与流程</h3>
<ul>
<li>客户端在局域网内发起一个 <a href="#ah"><em>DHCP Discover</em> </a>报文；</li>
<li>接收到<em>DHCP Discover</em>包的服务端会向请求的客户端发送一个 <a href="#ahh"><em>DHCP Offer</em> </a>报文;</li>
<li>客户端会广播一个<a href="#ahhh"><em>DHCP Request</em></a>，声明自己选用的服务端和IP地址；</li>
<li>服务端在接收到客户端广播的DHCP Request报文之后，就会判断该报文中的IP地址是否与自己的地址相同，如果相同，就会向客户端发送一个响应的DHCP ACK报文。</li>
</ul>
<blockquote>
<p>DHCP的前身是BOOTP协议，DHCP比BOOTP更复杂，功能也更加强大，<mark>但是在scapy和WireShark等流行工具中还是将DHCP协议分成DHCP和BOOTP两个部分来看待。</mark></p>
</blockquote>
<h3 id="python-如何实现">Python 如何实现</h3>
<p>利用 <em>ls()</em> 函数可以查找相关参数，我们利用以下程序查看scapy中两个部分的内容：</p>
<pre><code class="language-Python">from scapy.all import *
ls(BOOTP)
ls(DHCP)
</code></pre>
<ul>
<li><a id="ah"><em>DHCP Discover</em></a>数据包的构造：<br>
利用*RandMAC()*函数生成随机地址</li>
</ul>
<pre><code class="language-python">mac_random = str(RandMAC()) //转化成字符串形式
Ether_Discover = Ether(src = mac.random,dst=&quot;ff:ff:ff:ff:ff:ff&quot;)//16个f是广播的意思
</code></pre>
<p><em>BOOTP</em> 协议要设置的参数有<em>xid</em>、<em>chaddr</em>（<em>和以太中出现的src应该相同</em>）<br>
<em>DHCP</em> 协议要设置的参数是<em>options</em></p>
<pre><code class="language-python">from scapy.all import *
import binascii
xid_random = random.randint(1,100000000)
mac_random = str(RandMAC())
dhcp_discover = Ether(src=mac_random,dst=&quot;ff:ff:ff:ff:ff:ff&quot;)/IP(src=&quot;0.0.0.0&quot;,dst=&quot;255.255.255.255&quot;)/UDP(sport=68,dport=67)/BOOTP(chaddr=mac_random,xid=xid_random,flags=32768)/DHCP(options=[(&quot;message-type&quot;,&quot;discover&quot;),&quot;end&quot;])# sport：发出；dport：目标.  客户端：68；服务端：67.
sendp(dhcp_discover,iface='eth0')
print(&quot;yep______________________&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://unmaned-air.github.io/post-images/1650969152294.png" alt="" loading="lazy"></figure>
<ul>
<li>捕获<a id="ahh"><em>DHCP offer</em></a>数据包<br>
先运行如下程序</li>
</ul>
<pre><code class="language-python">from scapy.all import *
def d_d(pkt):
    if DHCP in pkt:
        pkt.show()
sniff(filter=&quot;src port 67&quot;,prn=d_d,coun=1)
</code></pre>
<p>再运行discover，得到下列数据<br>
<img src="https://unmaned-air.github.io/post-images/1650973730571.png" alt="" loading="lazy"></p>
<ul>
<li>构造<a id="ahhh"><em>DHCP Request</em></a>数据包</li>
</ul>
<ol>
<li>Ether部分需要设置两个参数src和dst</li>
<li>IP部分也是设置两个参数src和dst</li>
<li>传输层协议位UDP</li>
<li>BOOTP中需要指明xid和本机的MAC地址</li>
<li>DHCP中需要指明DHCP服务端的IP地址和申请的IP地址</li>
</ol>
<blockquote>
<p>Request = Ether_Request*()/IP_Request()/UDP_Request()/BOOTP()/DHCP_Request()</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-python">from scapy.all import*
def detect_dhcp(pkt):
    if DHCP in pkt:
        if pkt[DHCP].options[0][1]==2:
            E_R = Ether(src = pkt[BOOTP].chaddr,dst = pkt[Ether].src)
            I_R = IP(src=&quot;0.0.0.0&quot;,dst=&quot;255.255.255.255&quot;)
            U_R = UDP(sport = 68,dport = 67)
            B_R = BOOTP(chaddr=pkt[BOOTP].chaddr,xid = pkt[BOORP].xid)
            D_R = DHCP(options=[(&quot;message-type&quot;,'request),(&quot;server_id&quot;,pkt[DHCP].options[1][1]),(&quot;requested_addr&quot;,pkt[BOOTP].yiaddr),&quot;end&quot;])
             R=E_R/I_R/U_R/B_R/D_R
             sendp(R,iface='eth0')
             print(pkt[BOOTP].yiaddr+&quot;distributing&quot;)
     if pkt[DHCP].options[0][1]==5:
         print(pkt[BOOTP].yiaddr+&quot;distributed&quot;)
 sniff(filter=&quot;src port 67&quot;,prn=d_d,count=3)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器学习目录]]></title>
        <id>https://unmaned-air.github.io/post/ji-qi-xue-xi-mu-lu/</id>
        <link href="https://unmaned-air.github.io/post/ji-qi-xue-xi-mu-lu/">
        </link>
        <updated>2022-04-25T11:47:01.000Z</updated>
        <summary type="html"><![CDATA[<p>听我说，谢谢你：）</p>
]]></summary>
        <content type="html"><![CDATA[<p>听我说，谢谢你：）</p>
<!-- more -->
<p>（一）<a href="http://localhost:4000/post/ji-qi-xue-xi-de-ji-ben-gai-nian/">机器学习相关概念</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于kali虚拟机的网络渗透笔记]]></title>
        <id>https://unmaned-air.github.io/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-bi-ji/</id>
        <link href="https://unmaned-air.github.io/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-bi-ji/">
        </link>
        <updated>2022-04-25T08:40:12.000Z</updated>
        <content type="html"><![CDATA[<p>（一）<a href= "http://localhost:4000/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-ji-zhu/">scapy基础</a><br>
（二）<a href="http://localhost:4000/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-ji-zhu-yi-scapy-dhcp-ji-chu/">DHCP协议</a><br>
（三）DNS协议</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安全感的来源是自己的能力]]></title>
        <id>https://unmaned-air.github.io/post/an-quan-gan-de-lai-yuan-shi-zi-ji-de-neng-li/</id>
        <link href="https://unmaned-air.github.io/post/an-quan-gan-de-lai-yuan-shi-zi-ji-de-neng-li/">
        </link>
        <updated>2022-04-25T07:53:08.000Z</updated>
        <summary type="html"><![CDATA[<p>现在开始还来得及</p>
]]></summary>
        <content type="html"><![CDATA[<p>现在开始还来得及</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于kali虚拟机的网络渗透技术(一)scapy数据包基础]]></title>
        <id>https://unmaned-air.github.io/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-ji-zhu/</id>
        <link href="https://unmaned-air.github.io/post/ji-yu-kali-xu-ni-ji-de-wang-luo-shen-tou-ji-zhu/">
        </link>
        <updated>2022-04-24T05:14:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>虽然我大呼：“疫情滚出中国！！”<br>
但事物都具有两面性。感谢2022年4月的疫情让我的怨种导师监督我学习网络渗透</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>虽然我大呼：“疫情滚出中国！！”<br>
但事物都具有两面性。感谢2022年4月的疫情让我的怨种导师监督我学习网络渗透</p>
</blockquote>
<!-- more -->
<h3 id="__利用-scapy-库-__">__利用 <em>scapy</em> 库 __</h3>
<p>😀 利用 <em>pkt=Ether()/IP()/ICMP()</em> 构建一个数据包，往往，我们可以对数据包做出以下操作：</p>
<h4 id="显示数据包中的内容">😯显示数据包中的内容:</h4>
<p><em>pkt.raw()</em> 表示用字节格式显示内容<br>
<em>hexdump()</em> 十六进制显示<br>
<em>pkt.summary()</em> 用不超过一行的摘要描述数据包<br>
<em>pkt.show()</em> 用表单显示数据<br>
实现示例：</p>
<pre><code class="language-Python">from scapy.all import *
pkt=Ether()/IP()/ICMP()
 print(&quot;pkt.raw()\n&quot;)
print(raw(pkt))
print(&quot;hexdump()\n&quot;)
print(hexdump(pkt))
print(&quot;pkt.summary()\n&quot;)
print(pkt.summary())
print(&quot;pkt.show()\n&quot;)
pkt.show()
</code></pre>
<p><img src="https://unmaned-air.github.io/post-images/1650875445799.png" alt="" loading="lazy">&quot;</p>
<h4 id="抓数据包"><strong>😠抓数据包</strong></h4>
<p><em>wepcap(&quot;file.cap&quot;,pkt)</em> 后者指要保存的数据包，前者指保存去的文件名<br>
<em>rec = rddpcap(&quot;file.cap&quot;)</em> 读取数据包<br>
实现示例：</p>
<pre><code class="language-python">  from scapy.all import *
  pkt=IP()/ICMP()
  print(&quot;get\n&quot;)
  wrpcap(&quot;get.cap&quot;,pkt)
  print(&quot;read\n&quot;)
  rec=rdpcap(&quot;get.cap&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://unmaned-air.github.io/post-images/1650896283998.png" alt="" loading="lazy"></figure>
<h4 id="发送数据包"><strong>🤓发送数据包</strong></h4>
<p><em>send()</em> 对IP地址发送数据包<br>
<em>sendp()</em> 对硬件地址发送数据包（MAC）<br>
实现示例：</p>
<h4 id="发送和接受"><strong>😋发送和接受</strong></h4>
<p>*sr()*用于IP地址<br>
<em>srp()<em>用于MAC地址</em>（物理地址）</em><br>
实现示例：</p>
<h4 id="抓包函数"><strong>😏抓包函数：</strong></h4>
<p><em>sniff(filter= ... ,iface=&quot;  ...&quot;,prn= ... ,count= ... )</em> 参数说明：<br>
filter：过滤器，要监听的地址（ 要抓<mark>什么样的数据包</mark> ）<br>
iface：用来指定要用的网卡（从哪作为<mark>去抓</mark>数据包的地方）<br>
prn：指向一个函数，是要对数据包做的处理（做什么）<br>
cout：指定要监听到的数据包的数量</p>
]]></content>
    </entry>
</feed>